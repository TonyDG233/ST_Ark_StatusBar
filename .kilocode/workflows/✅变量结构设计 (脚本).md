task: Explorer requests to design the zod schema of variables which records the world status, you should reappear an instance of it using zod 4.x inside `<context>`, which is the main content of your reply
rule:
  - libraries: "`z` from zod and `_` from lodash are available by default, so you can use them directly and should prefer to use them; don't import them in the generated code"
  - zod 4: stick to use zod 4.x, never ever use `.passthrough`!
  - idempotent operation: the schema is intended to parse the updates of the world status incrementally, thus, the output of `Schema.parse(input)` must be a valid input of `Schema.parse` itself; that is, you should use z.transform carefully, keeping `Schema.parse(Schema.parse(input))` equal to `Schema.parse(input)`
  - for number schema: prefer `z.coerce.number()` over `z.number()` whenever you expect a number since it will try to convert the input to a number if it's not a number; but don't use other `z.coerce.xxx()` such as `z.coerce.boolean()`, just use `z.boolean()` directly
  - prefer object schema over array schema: "the array index is hard to understand and maintain, so you should use `物品栏: z.record(z.string().describe('物品名'), z.object({ 描述: z.string(), ... }))` instead of `物品栏: z.array(z.object({ 名称: z.string(), 描述: z.string(), ... }))`"
  - for object schema:
      - fixed required keys + the same type: use `z.record(z.enum(['key1', 'key2', ...]), ${value type})`
        fixed optional keys + the same type: use `z.partialRecord(z.enum(['key1', 'key2', ...]), ${value type})`
        dynamic optional keys + the same type: use `z.record(z.string(), ${value type})`
        fixed required keys + different types: 'use `z.object({ key1: ${type1}, key2: ${type2}, ... })`'
        dynamic keys but some keys are required + the same type: 'use `z.intersection(z.object({ requiredKey1: ${type1}, requiredKey2: ${type2}, ... }), z.record(z.string(), ${value type}))`'
      - on clearable object: 'if the object is clearable by JSON patch `{ "op": "remove", "path": "/path/to/object" }`, set `z.object({ ...prefault for every field }).prefault({})` instead of `z.object({ ... }).optional()` for better compatibility with the incremental update'
  - for special format (rare to happen): prefer `z.templateLiteral` over regex or manual parsing
  - for restrictions: when accepting a update that breaks the schema, users are tend to expect the update takes some effect instead of being discarded completely; therefore, you should try your best to use `z.transform` to convert the broken input to a valid input. For example, if Explorer requests a value to be between 0 and 100, prefer `z.number().transform(value => _.clamp(value, 0, 100))` over `z.number().min(0).max(100)`; if an object could only contain 10 keys, when a new key comes, discard the oldest key instead. **but only impose these restrictions when Explorer requests**
  - on default value:
      - prefer `z.prefault` over `z.default`
      - if a `z.object` is complicated enough, set `.prefault('${suitable default value}')` or `.or(z.literal('待初始化')).prefault('待初始化')` for every field of it
      - don't set `z.prefault` for other situatioins unless Explorer requests it
  - when to describe: use `z.describe` only when there's no field name to explain the usage of the schema such as the key type of `z.record`; in contrast, you should never use `z.describe` if the field name has already explained the usage well
  - determine the order of keys: 'if Explorer requests you to do something with the insertion time of keys, prefer to use `_(data).entries()` which almost always lists keys in insertion order, e.g. you can remove old keys with a simple `_(data).entries().takeRight(10)`; when keys are already additionally sorted inside `z.transform`, you should use `$time: z.coerce.number().prefault(() => Date.now())` to automatically assign a timestamp'
  - don't repeat yourself: merge the same variable schemas whenever possible, but don't define extra variables to do so - you can only define schema inside `export const Schema = z.object({ ... })`
  - type of functions:
      - '`registerMvuSchema = (schema: z.ZodObject | (() => z.ZodObject)) => void`, the function input `() => z.ZodObject` could be used when the schema is not ready at the time of registering, or the schema depends on runtime data/function'
      - '`z.transform(value => value)`'
      - '`z.prefault/z.catch(value | () => value)`'
  - REPEAT: DON'T mark any variable as optional, set `z.prefault` for simple types or impose any restriction to the schema unless Explorer requests them
format: |-
  <context>
  NOTE: 请新建一个酒馆助手脚本名为`MVU`, 将代码块中的内容复制到脚本中
  ```js
  import 'https://testingcf.jsdelivr.net/gh/MagicalAstrogy/MagVarUpdate/artifact/bundle.js'
  ```

  NOTE: 请再新建一个酒馆助手脚本名为`变量结构`, 将代码块中的内容复制到脚本中
  <variable_schema>
  ```js
  import { registerMvuSchema } from 'https://testingcf.jsdelivr.net/gh/StageDog/tavern_resource/dist/util/mvu_zod.js';
  $(DON'T IMPORT zod OR lodash HERE, USE THEM DIRECTLY!)

  export const schema = z.object({
    ...
  });

  $(() => {
    registerMvuSchema(Schema);
  })
  ```
  ${explain why you construct the schema as is and how the schema satisfies the needs in plain Chinese...}
  </variable_schema>
  </context>